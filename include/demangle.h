/*
 * Copyright 2025 Andrea Bocci, Simeon Ehrig
 * SPDX-License-Identifier: MPL-2.0
 */

/*
 * C++20 compile-time demangled type name, based on
 *   https://www.reddit.com/r/cpp/comments/lfi6jt/finally_a_possibly_portable_way_to_convert_types/
 *   https://rodusek.com/posts/2021/03/09/getting-an-unmangled-type-name-at-compile-time/
 */

#pragma once

#include <array>
#include <source_location>
#include <string_view>
#include <utility>

namespace
{

    // Use a fundamental type to detect the prefix and suffix, because MSVC includes the class, struct, or union
    // keyword in the type signature.
    using test_pattern_type = double;

    constexpr std::string_view test_pattern_name("double");

    // Generate a function name with full type signature that includes the user-provided type name.
    // Use the compiler-specific extensions for known compilers because nvc++ does not include the full type signature
    // in std::source_location::current().function_name() .
    template<typename T>
    consteval std::string_view embed_type_name()
    {
#if defined(__GNUC__) || defined(__clang__) || defined(__PGI) || defined(__NVCOMPILER)
        // gcc, clang, PGI, nvc++
        return __PRETTY_FUNCTION__;
#elif defined(_MSC_VER)
        // MSVC
        return __FUNCSIG__;
#else
        // unknown compiler, use the c++20 standard approach
        return std::source_location::current().function_name();
#endif
    }

    template<typename T>
    consteval auto demangle_as_array()
    {
        // embed a known type, and use it to extract the prefix and suffix generated by the compiler
        constexpr std::string_view embedded_pattern = embed_type_name<test_pattern_type>();
        constexpr size_t prefix_size = embedded_pattern.find(test_pattern_name);
        constexpr size_t suffix_size = embedded_pattern.size() - prefix_size - test_pattern_name.size();

        // embed T, and use the known prefix and suffix length to determien the type name's position and size
        constexpr std::string_view embedded_type = embed_type_name<T>();
        constexpr size_t start = prefix_size;
        constexpr size_t end = embedded_type.size() - suffix_size;
        static_assert(start < end);
        constexpr size_t length = end - start;

        // copy the demangled type name into an array, and add a null terminaton character
        std::array<char, length + 1> storage;
        std::copy(embedded_type.data() + start, embedded_type.data() + end, storage.data());
        storage[length] = '\0';

        return storage;
    }

    template<typename T>
    inline constexpr auto storage = demangle_as_array<T>();

    template<typename T>
    consteval std::string_view demangle()
    {
        return std::string_view{storage<T>.data(), storage<T>.size()};
    }

} // namespace

template<typename T>
inline constexpr std::string_view demangled = demangle<T>();
